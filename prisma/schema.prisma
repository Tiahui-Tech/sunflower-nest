generator client {
  provider = "node node_modules/prisma-nestjs-graphql"
  output = "../src/@generated"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Represents possible genders.
enum Gender {
  MALE
  FEMALE
  NON_BINARY
}

// It represents the status of the anime, in terms of whether it is on air, finished, upcoming, etc.
enum AnimeStatus {
  // Anime is currently on air.
  ONGOING

  // Anime has finished airing.
  FINISHED

  // Anime is yet to be aired.
  UPCOMING

  // Anime is on an indefinite break
  HIATUS

  // Anime is in a temporary and definite break
  ON_BREAK

  // Anime was cancelled/abandoned suddenly
  DROPPED
}

// Represents a user or profile.
model User {
  id             Int         @id @unique @default(autoincrement())
  email          String      @unique @db.VarChar(255) 
  username       String      @unique @db.VarChar(12) 
  avatarURL      String 
  gender         Gender 
  followersCount Int        @default(0) 
  followedCount  Int        @default(0) 
  animesCount    Int        @default(0) 
  reviewsCount   Int        @default(0) 
  favoriteGenres UserGenre[] 
  favoriteAnimes UserAnime[]
  followed       Follower[]  @relation("UserFollows")
  followers      Follower[]  @relation("UserFollowedBy")
  reviews        Review[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt 

  @@index([id])
}

// Intermediate model for connecting the followers/following of an individual user
model Follower {
  id         Int  @id @default(autoincrement())
  followedId Int
  followerId Int
  followed   User @relation("UserFollows", fields: [followedId], references: [id])
  follower   User @relation("UserFollowedBy", fields: [followerId], references: [id])

  createdAt DateTime @default(now())

  @@index([id, followedId, followerId])
}

// Represents a genre of anime.
model Genre {
  id     Int         @id @default(autoincrement())
  name   String 
  animes Anime[] 
  fans   UserGenre[] 

  createdAt DateTime @default(now()) 

  @@index([id]) 
}

// Represents an individual anime.
model Anime {
  id       Int         @id @default(autoincrement()) 
  title    String 
  synopsis String 
  genres   Genre[]
  reviews  Review[] 
  episodes Episode[] 
  casts    Cast[] 
  fans     UserAnime[] 

  createdAt DateTime @default(now()) 
  updatedAt DateTime @updatedAt 

  @@index([id]) 
}

// Intermediate model connecting a user and an anime they are a fan of.
model UserAnime {
  userId  Int 
  animeId Int 
  user    User  @relation(fields: [userId], references: [id]) 
  anime   Anime @relation(fields: [animeId], references: [id]) 

  createdAt DateTime @default(now()) 

  @@id([userId, animeId]) 
}

// Intermediate model connecting a user and a genre they are a fan of.
model UserGenre {
  userId  Int
  genreId Int
  user    User  @relation(fields: [userId], references: [id])
  genre   Genre @relation(fields: [genreId], references: [id]) 

  createdAt DateTime @default(now()) 

  @@id([userId, genreId]) 
}

// Represents a review of an anime.
model Review {
  id      Int    @id @default(autoincrement()) @map("reviewID") 
  user    User   @relation(fields: [userId], references: [id]) 
  userId  Int 
  anime   Anime  @relation(fields: [animeId], references: [id]) 
  animeId Int 
  content String 

  createdAt DateTime @default(now()) 
  updatedAt DateTime @updatedAt 

  @@index([id]) 
}

// Represents an episode of an anime.
model Episode {
  id       Int    @id @default(autoincrement()) @map("episodeID") 
  anime    Anime  @relation(fields: [animeId], references: [id]) 
  animeId  Int 
  season   Int 
  coverURL String 
  title    String 
  duration Int 

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt 

  @@index([id]) 
}

// Represents a cast member of an anime.
model Cast {
  id       Int     @id @default(autoincrement()) @map("castID") 
  name     String 
  coverURL String 
  animes   Anime[] 

  createdAt DateTime @default(now()) 
  updatedAt DateTime @updatedAt 

  @@index([id]) 
}
